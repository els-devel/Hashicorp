# Vault Internals
## Overview
### Architecture
* Storage Backend = Postgres12
* Secrets Engine = Databases
* Vault Encryption Protocol = Shamirs Secret Sharing
* After vault is unsealed, requests can be processed from HTTP API to the Core
* The Core: manages requests, enforces ACLs, ensures audit logging
* Authentication method: user/password for manual, keys/tokens for applications
	validation returns a list of policies
* Policies: named ACL rules: "root" is built in ("full access"). Vault operates in whitelist mode by default, meaning you need a policy to specify access or you will have no access
If the policies authorize the user request, the request is routed to the secrets engine
* Secret is returned with a Lease ID - used to renew or revoke
* write-ahead logging is used by core for partial failure cases

### HA MODE
* unsealed vault can act as a standby server

### Security
* All data leaves vault with 246AES cipher
* External Threats: Clients over TLS provide a token for each request

### Logging
* To configure log path
'''vault audit enable file file_path=/var/log/vault_audit.log''' for file logger
'''vault audit enable syslog''' for syslogger
### Tokens
* Properties: ID, Display Name, Metadata, Number of Uses, Parent ID, Policies, Source Path

    ID - The primary ID of a token is a randomly generated value
    Display Name - Optionally, a human readable display name
    Metadata - Metadata used for audit logging
    Number of Uses - Optionally, a restricted use count
    Parent ID - Optionally, a parent token which created this child token
    Policies - An associated list of ACL policies
    Source Path - The path at which the token was generated (e.g. auth/github/login)
    
### Multi-site replication
* supported in v0.7
* Uses: Multi-Datacenter Deployments, Backup Sites, Scaling Throughput
### Plugins
* both built-in and external, all secret backends are plugins 
* don't share vault mem. space, don't have access to unencrypted data

###### Concepts
### Dev Server
* Initialized and unsealed, single unseal key
* In memory storage
### Seal/Unseal
* Unsealing requires constructing the master key, which reads the decryption key
* Master Key must be reconstructed from shards (so how does this pertain to API access?)
* command line to unseal is "vault operator unseal"
* can be resealed via api or automatically when server is restarted
* AUTO-UNSEAL (this seeems like what we want). 
The seal can be migrated from Shamir Keys to Auto Unseal - process for this
* Can Shamir's technique be disabled and the Master Key used directly? (i.e. I store it on my computer, and keep a hard copy as well?) Vault only needs to be unsealed each time it restarts.
The service that unseals it is going to have to call for the Master, wherever that is, or call
for the shards if Shamir's is used.
### Lease
* metadata about each token released with token (duration, etc)
* lease can be revoked or can expire, at which point it must be renewed with a new token
### auth-methods
* use 'path-help' command to learn about auth methods for each backend, as they differ
* for our purpose this will be done per machine, via api (need to know path endpoint)
* tokens given at authorization
* auths have leases just like tokens
### tokens
* have attached policies, which control access rights
* root tokens have all access rights, one is generated by default at init
* two types: service (normal) and batch (lightweight, less features)
* each token has a total time to live (TLL), but can be renewed until max TLL is reached
* there is also a system max TLL of 32days (configurable)
* CIDR-binding can be set to bind tokens to a range of client IPs
### response-wrapping
* if we choose to use this, will basically wrap and secure the secret as it moves from Vault to SCADA to client machine, so that only the client sees the cleartext
### Policies
* vault workflow is: 
1)administrator configures vault to connect to auth method
2)administrator creates policies that grant access to paths (e.g. database/pg12/fAdmin_passwords )
3)policy is uploaded to vault & mapped to an auth method
* note: vault will not return an error when deleting a policy that does not exist
### Path
* capabilities: create, read, update, delete, list, sudo, deny


# OS Configuration for Vault Server

## Minimal Build 19.10

* Install 19.10

# Manual Install and Setup

## Installing Vault

### Go to https://www.vaultproject.io and download the latest release for Linux
* mkdir -p /vault/bin
* Unzip the download in /vault/bin
* export PATH=$PATH:/vault/bin
* 

## Starting Vault
* vault server -config=config.hcl
* vault operator init

## Backing up Vault
* It isn't in the documentation but per mailing list response vaults data is stored in whatever backend it is configured with
1) Stop vault (systemctl stop vault)
2) backup the postgresdb
3) restart vault server with the correct config file 

